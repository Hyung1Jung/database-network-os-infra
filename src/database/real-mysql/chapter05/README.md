# 5장, 인덱스

## 5.1 디스크 읽기 방식

### 5.1.1 저장 매체
서버에 사용되는 데이터를 저장할 수 있는 매체는 크게 3가지로 나뉜다.
- 내장 디스크(Internal Disk)
- DAS(Direct Attached Storage)
- NAS(Network Attached Storage)
- SAN(Storage Area Nework)

## 5.2 인덱스란?
DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.

인덱스를 역할로 구분해본다면 PK와 보조 키로 구분할 수 있다.
- PK : 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
- 보조키 : PK를 제외한 나머지 모든 인덱스
PK를 제외한 나머지 모든인덳는 보조 인덱스라고 분류한다, 유니크 인덱스는 PK와 성격이 비슷하고 PK를 대체해서 사용할 수 있다고
해서 대체 키라고도 하는데, 별도로 분류하기도 하고 그냥 보조 인덱스로 분류하기도 한다.
  
데이터 저장 방식(알고리즘)별로 구분하는 것은 사실 상당히 많은 분류가 가능하겠지만 대표적으로 `B-Tree 인덱스`와 `Hash
인덱스`로 구분할 수 있다. 최근 새롭게 `Fractal-Tree` 인덱스와 같은 알고리즘도 도입됐다.
- B-Tree : B-Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash : Hash 인덱스 알고리즘은 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.
  하지만 값을 변형해서 인덱싱하므로, 전방(Prefix) 일치와 같이 값의 일부만 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.
  Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.
- Fractal-Tree : Fractal-Tree 알고리즘은 B-Tree의 단점을 보완하기 위해 고안된 알고리즘이다. 값을 변형하지 않고 
  인덱싱하며 범용적인 목적으로 상요할 수 있다는 측면에서 B-Tree와 거의 비슷하지만 데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게
  설계된 것이 특징이다.
  
데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다. 유니크 인덱스에 대해 동등 조건으로 
검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려 주는 효과를 낸다.

## 5.2 B-Tree 인덱스란?
B-Tree에는 여러 가지 변형된 형태의 알고리즘이 있는데, 일반적으로 DMBS에서는 주로 B+-Tree 또는 B*-Tree가 사용된다. 
`* B-Tree의 "B"는 Binary의 약자가 아니라 Balanced를 의미한다.`

B-Tree는 칼럼의 원래 값을 변형시키지 않고(물론 값의 앞부분만 잘라서 관리하기는 하지만) 인덱스 구조체 내에서는 항상 정렬된 상태로
유지하고 있다.

### 5.3.1. 구조 및 특성
B-Tree는 트리 구조로 됭있다. 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 "브렌치 노드"라고 한다. 데이터베이스에서
인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.

![1](https://user-images.githubusercontent.com/43127088/108980637-37b74e80-76cf-11eb-97bf-51006338edac.PNG)

인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 이를 위해 인덱스의
리프 노드는 데이터 파일에 저장된 레코드의 주소를 가지게 된다.

![1](https://user-images.githubusercontent.com/43127088/108987000-2291ee00-76d6-11eb-8d42-ff0d59235832.jpg)

InnoDB 테이블에서는 PK에 의해 클러스터링되기 때문에 PK 자체가 주소 역할을 한다.

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**
B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 
키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 만약 리프 노드가 꽉 차서 더는 저장할 수 없을 떄는 리프
노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이러한 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가 하는 작업)에 비용이 많이
드는 것으로 알려졌다.

**인덱스 추가로 인해 INSERT나 UPDATE 문장이 어떤 영향을 받을까? 테이블의 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성 등을 확인해야 한다.

대략적으로 계산하는 방법은 테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을
1~1.5 정도로 예측하는 것이 일반적이다. 일반적으로 테이블에 인덱스가 3개(테이블의 모든 인덱스가 B-Tree라는 가정하에)가 있다면 이떄 테이블에
인덱스가 하나도 없는 경우 작업 비용이 1이고, 3개인 경우에는 5.5 정도의 비용(1.5 * 3 + 1)정도로 예측해 볼 수 있다. 중요한 것은
이 비용의 대부분이 메모리와 CPU에서 처리하는 시간이 아니라 `디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 하기 때문에 시간이 오래 걸린다는 것`이다.

InnoDB 스토리지 엔진은 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지, 아니면 바로 처리할지 결정한다.

![1](https://user-images.githubusercontent.com/43127088/108990632-78689500-76da-11eb-93c6-c924df24bff6.PNG)

1. 사용자의 쿼리 실행
2. InnoDB 버퍼 풀에 새로운 키 값을 추가해야 할 페이지(B-Tree의 리프 노드)가 존재한다면 즉시 키 추가 작업 처리
3. 버퍼 풀에 B-Tree의 리프 노드가 없다면 인서트 버퍼에 추가할 키 값과 레코드의 주소를 임시로 기록해 두고 작업 완료(사용자의 쿼리는 실행 완료됨)
4. 백그라운드 작업은 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키값이 있는지 확인한 후, 있다면 병합함(B-Tree에
   인덱스 키와 주소를 저장)
5. 데이터베이스 서버 자원의 여유가 생기면 MySQL 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키와 
   주소 값을 머지(B-Tree에 인덱스 키와 주소를 저장)시킴 
   
이 기능은 `체인지 버퍼링`이라고한다. 관련 설정 파라미터로 `innodb_chanage_buffering`가 있다. 

버퍼에 의해 인덱스 키 추가 작업이 지연되어 처리된다 하더라도, 이는 사용자에게 아무런 악영향 없이 투명하게 처리되므로 개발자는 이를 
신경쓰지 않아도 된다. `innodb_chanage_buffering`설정 값을 이용해 키 추가 작업과 키 삭제 작업 중 어느 것을 지연처리할지 설정해야 한다.

**인덱스 키 삭제**
해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만하면 작업이 완료된다. 이렇게 삭제 마키된 인덱스 키 공간은
계속 그대로 방치하거나 또는 재활용할 수 있다. 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 필요한 
작업이다. 

**인덱스 키 변경**
인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키값이 변경되는 경우에는 단순히 인덱스상의
키값만 병경하는 것은 불가능하다. B-Tree의 키값 변경 작업은 먼저 키값을 삭제한 후, 다시 새로운 키값을 추가하는 형태로 처리된다.

**인덱스 키 검색**
INSERT, UPDATE, DELETE 작업을 할 떄 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다.

검색 작업은 `트리 탐색` 과정을 거친다. 인덱스 트리 탐색은 SELECT에서만 사용하는 것이 아니라 UPDATE나 DELETE를 처리하기 위해 
항상 해당 레코드를 먼저 검색해야 할 경우애에도 인덱스가 있으면 빠른 검색이 가능하다. B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.
또한 인덱스를 이용한 검색에서 중요한 사실은 인덱스의 키값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색
기능을 사용할 수 없다는 것이다. 이미 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니다. 따라서 함수나 연산을 수행한 결과로 정렬한다거나
검색하는 작업은 B-Tree의 장점을 이용할 수 없으므로 주의해야 한다.

InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다. InnoDV 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락(갭 락)이
검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼있다. 따라서 UPDATE나 DELETE 문장이 실행될 때
테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 테이블의 모든 레코드를 잠글 수도 
있다. InnoDB 스토리지 엔진에서는 그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 끼친다는 것이다.


